Спільна пам'ять процесів




﻿Спільна пам'ять — це ключова концепція в багатопроцесорному програмуванні, яка дозволяє різним процесам чи потокам спільно використовувати дані. Це важливо для ефективної комунікації та обміну даними між процесами, але вимагає ретельного управління для запобігання конфліктам.



Спільна пам'ять може бути класифікована як глобальна пам'ять, яка доступна всім процесам, і стекова пам'ять, яка використовується для зберігання тимчасових даних. Розуміння цих типів допоможе у виборі правильного підходу до синхронізації та управління даними.



Глобальна пам'ять є важливою формою спільної пам'яті в багатопроцесорних додатках, де різні процеси потребують спільного доступу до одних і тих самих даних. Глобальна пам'ять дозволяє процесам ділитися даними і ресурсами, що є основою для взаємодії та обміну даними між процесами.



Стекова пам'ять зазвичай асоціюється з потоками в межах одного процесу. Кожен потік у мультипотоковому процесі має власний стек, який використовується для зберігання тимчасових даних, таких як локальні змінні та інформація про виклики функцій. Це ключове для управління виконанням кожного потоку в межах процесу.



Для уникнення проблем з одночасним доступом до спільної пам'яті важливо використовувати механізми синхронізації, такі як м'ютекси та семафори. Ці інструменти допомагають управляти доступом до спільних ресурсів і запобігають гонкам даних.



У Python м'ютекси (Mutexes) використовуються для гарантії взаємного виключення. Це означає, що лише один потік може виконувати певний фрагмент коду в один момент часу. У Python м'ютекси часто реалізовані через клас Lock або RLock у модулі multiprocessing.



Семафори (Semaphores) — це більш загальний механізм синхронізації, який може дозволити одночасний доступ до спільної пам'яті для певної кількості потоків. У Python семафори реалізовані через клас Semaphore у тих же модулях.

Спільна пам'ять підтримується не всіма операційними системами та може бути заборонена політикою безпеки.



Щоб створити область спільної пам'яті, потрібно вказати ОС, скільки пам'яті необхідно виділити. Для обчислення обсягу пам'яті обов'язково потрібно вказати тип даних, який буде використовуватись, та кількість елементів для складних типів. Крім того, механізми обмеження доступу до спільного ресурсу також потрібно забезпечити самостійно, інакше дані можна зіпсувати при спробі одночасного доступу для зміни із різних процесів.



Розглянемо приклади, які демонструють різні способи роботи зі спільною пам'яттю у багатопроцесорних додатках. 


Наприклад, використання об'єктів Value і Array у модулі multiprocessing Python дозволяє ефективно розподіляти спільні дані та управляти ними .



from multiprocessing import Process, Value, RLock, current_process
from time import sleep
import logging
import sys

logger = logging.getLogger()
stream_handler = logging.StreamHandler()
logger.addHandler(stream_handler)
logger.setLevel(logging.DEBUG)

def worker(val: Value):
    logger.debug(f'Started {current_process().name}')
    sleep(1)
    with val.get_lock():
        val.value += 1
    logger.debug(f'Done {current_process().name}')
    sys.exit(0)

if __name__ == '__main__':
    lock = RLock()
    value = Value('d', 0, lock=lock)
    pr1 = Process(target=worker, args=(value, ))
    pr1.start()
    pr2 = Process(target=worker, args=(value, ))
    pr2.start()

    pr1.join()
    pr2.join()

    print(value.value)  # 2.0



Виведення:



Started Process-1
Started Process-2
Done Process-1
Done Process-2
2.0



У цьому прикладі ми скористалися механізмом спільної пам'яті Value. Було обрано десятковий тип даних ('d'). Докладніше про доступні типи та їхні назви можна дізнатися з документації.



Щоб створити спільну пам'ять для процесів, необхідно визначити тип даних, який буде знаходитися у виділеній області пам'яті. Це порушує звичний для Python підхід, коли не потрібно думати про те, який тип даних буде використовуватися і скільки місця він може займати.



Давайте розберемо складніший приклад, із використанням структур у спільній пам'яті:


from multiprocessing import Process, RLock, current_process
from multiprocessing.sharedctypes import Value, Array
from ctypes import Structure, c_double
import logging

logger = logging.getLogger()
stream_handler = logging.StreamHandler()
logger.addHandler(stream_handler)
logger.setLevel(logging.DEBUG)

class Point(Structure):
    _fields_ = [('x', c_double), ('y', c_double)]

def modify(num: Value, string: Array, arr: Array):
    logger.debug(f'Started {current_process().name}')
    logger.debug(f"Change num: {num.value}")
    with num.get_lock():
        num.value **= 2
    logger.debug(f"to num: {num.value}")
    with string.get_lock():
        string.value = string.value.upper()
    with arr.get_lock():
        for a in arr:
            a.x **= 2
            a.y **= 2
    logger.debug(f'Done {current_process().name}')

if __name__ == '__main__':
    lock = RLock()
    number = Value(c_double, 1.5, lock=lock)
    string = Array('c', b'hello world', lock=lock)
    array = Array(Point, [(1, -6), (-5, 2), (2, 9)], lock=lock)

    p = Process(target=modify, args=(number, string, array))
    p2 = Process(target=modify, args=(number, string, array))
    p.start()
    p2.start()
    p.join()
    p2.join()
    print(number.value)
    print(string.value)
    print([(arr.x, arr.y) for arr in array])



Виведення буде:



Started Process-2
Change num: 1.5
to num: 2.25
Done Process-2
Started Process-1
Change num: 2.25
to num: 5.0625
Done Process-1
5.0625
b'HELLO WORLD'
[(1.0, 1296.0), (625.0, 16.0), (16.0, 6561.0)]



У цьому прикладі ми створили:

структуру Point, яка описує координати точки на площині;
дробове число number;
рядкову змінну string (підтримуються тільки byteрядки);
масив array, який містить координати точок відповідно до структури Point.


Зверніть увагу!
Для опису полів структури їх потрібно помістити у список кортежів _fields_, де кожен кортеж — це ім'я і тип поля. Масив Array поводиться багато в чому як список і дозволяє зберігати в ньому різнотипні дані, але його розмір статичний і додавати/видаляти елементи не можна. Так само як і змінювати тип існуючих.


Також у структурі даних ми передали механізм блокування через параметр lock. Як Value, так і Array забезпечують блокування ресурсу, до якого можна отримати доступ, щоб як читати, так і оновлювати дані.